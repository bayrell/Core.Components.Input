/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web.CRUD;

use Runtime.rtl;
use Runtime.lib;
use Runtime.BaseObject;
use Runtime.Core.ApiException;
use Runtime.Core.RemoteCallAnswer;
use Runtime.Core.RemoteCallRequest;
use Runtime.ORM.CursorInterface as Cursor;
use Runtime.ORM.DriverInterface as ORMDriver;
use Runtime.ORM.QueryBuilder;
use Runtime.Web.Backend.ApiList;
use Runtime.Web.Backend.ApiMethod;
use Runtime.Web.CRUD.CrudApi;
use Runtime.Web.CRUD.FieldInfo;


class CrudApi extends BaseObject
{
	string action = "";
	RemoteCallAnswer answer = null;
	RemoteCallRequest request = null;
	Collection<FieldInfo> struct = null;
	
	/* Search */
	var filter = null;
	QueryBuilder q = null;
	int page = 0;
	int pages = 0;
	int total = 0;
	int limit = 100;
	Collection<Dict> items = null;
	
	/* Save */
	Map<Vector<string>> fields_errors = new Map();
	Dict pk = null;
	Dict item = null;
	Dict new_item = null;
	Dict old_item = null;
	bool is_success = false;
	
	
	/**
	 * Returns crud table name
	 */
	pure string getTableName() => "";
	
	
	
	/**
	 * Returns crud table name
	 */
	bool isSuccess() => this.is_success;
	
	
	
	/**
	 * Returns table field value
	 */
	Collection<FieldInfo> settings() => [];
	
	
	
	/**
	 * Returns struct
	 */
	Collection<FieldInfo> getStruct()
	{
		if (this.struct == null) this.struct = this.settings();
		return this.struct;
	}
	
	
	
	/**
	 * Returns primary key by item
	 */
	Dict getPrimaryKeyFromItem(Dict item)
	{
		Map pk = new Map();
		Collection<FieldInfo> settings = this.getStruct();
		settings = settings.filter( lib::equalAttr("primary", true) );
		for (int i=0; i < settings.count(); i++)
		{
			FieldInfo field = settings[i];
			var value = item[field.api_name];
			pk.set(field.api_name, value);
		}
		return pk.toDict();
	}
	
	
	
	/**
	 * Returns table field value
	 */
	Collection<Collection<string>> getDefaultOrder() =>
	[
		["id", "desc"]
	];
	
	
	
	/**
	 * Returns default limit
	 */
	int getDefaultLimit() => 10;
	
	
	
	/**
	 * Returns maximum limit
	 */
	Collection<Collection<string>> getMaxLimit() => 1000;
	
	
	
	/**
	 * Init request
	 */
	async void init()
	{
	}
	
	
	
	/**
	 * Process item before response
	 */
	async Dict processItem(Dict item)
	{
		return item;
	}
	
	
	
	/**
	 * Process items
	 */
	async void processItems()
	{
	}
	
	
	
	/**
	 * Convert primare key before query
	 */
	async Dict convertPrimaryKey(Dict pk)
	{
		return pk;
	}
	
	
	
	/**
	 * Convert item before save to database
	 */
	async Dict convertItem(Dict item)
	{
		Collection<FieldInfo> settings = this.getStruct();
		Dict item_keys = item.keys();
		
		for (int i=0; i<settings.count(); i++)
		{
			FieldInfo field = settings[i];
			var value = item[field.api_name];
			
			/* Set default value */
			var default_value = field["default"] |> default bool false;
			if (rtl::isEmpty(value))
			{
				item = rtl::setAttr(item, field.api_name, default_value);
			}
		}
		
		for (int i=0; i<item_keys.count(); i++)
		{
			string key = item_keys[i];
			FieldInfo field = FieldInfo::getFieldInfo(settings, key);
			
			/* Remove if key does not exists */
			if (field == null)
			{
				item = item.removeIm(key);
				continue;
			}
			
			/* Remove readonly key */
			bool readonly = field["readonly"] |> default bool false;
			if (readonly)
			{
				item = item.removeIm(key);
			}
			
			/* Can create */
			bool can_create = field["can_create"] |> default bool false;
			if (this.action == "create" and not can_create)
			{
				item = item.removeIm(key);
			}
			
			/* Can update */
			bool can_update = field["can_update"] |> default bool false;
			if (this.action == "update" and not can_update)
			{
				item = item.removeIm(key);
			}
		}
		
		return item;
	}
	
	
	
	/**
	 * Process item from database
	 */
	async Dict fromDatabase(Dict item)
	{
		return item;
	}
	
	
	
	/**
	 * Process item to database
	 */
	async Dict toDatabase(Dict item)
	{
		return item;
	}
	
	
	
	/**
	 * Add error
	 */
	async bool addFieldError(string field_name, string error)
	{
		if (not this.fields_errors.has(field_name))
		{
			this.fields_errors.set(field_name, new Vector());
		}
		Vector<string> errors = this.fields_errors[field_name];
		errors.push(error);
	}
	
	
	
	/**
	 * Validate form
	 */
	async bool validateForm()
	{
		bool res = true;
		
		Collection<FieldInfo> settings = this.getStruct();
		for (int i=0; i<settings.count(); i++)
		{
			FieldInfo field = settings[i];
			var value = this.item[field.api_name];
			if (field == null) continue;
			
			bool required = field["required"] |> default bool false;
			if (required and rtl::isEmpty(value))
			{
				this.addFieldError( field.api_name, _("Runtime.Web.CRUD", "This field must be filled") );
				res = false;
			}
		}
		
		return res;
	}
	
	
	
	/**
	 * Validate
	 */
	async bool validate()
	{
		if (this.action == "add" or this.action == "update")
		{
			list res = await this.validateForm();
			if (not res)
			{
				throw new ApiException
				(
					_("Runtime.Web.CRUD", "Validation fields error"),
					rtl::ERROR_VALIDATION,
					{
						"fields_errors": this.fields_errors
					}
				);
			}
		}
	}
	
	
	
	/**
	 * After
	 */
	async bool after()
	{
	}
	
	
	
	/**
	 * Returns item by pk
	 */
	async Dict getByPrimaryKey(Dict pk)
	{
		Dict item = null;
		string table_name = static::getTableName();
		
		/* Process primary key */
		pk = await this.convertPrimaryKey(pk);
		if (pk != null)
		{
			pk = this.toDatabase(pk);
			
			/* Get ORM driver */
			ORMDriver orm = @.getDriver(classof ORMDriver);
			
			/* Create query */
			Cursor cursor = await orm.select(table_name, pk, 0, 1);
			Dict item = cursor.fetchOne();
			await cursor.close();
			
			/* From database */
			item = await this.fromDatabase(item);
		}
		return item;
	}
	
	
	
	/**
	 * Build query
	 */
	QueryBuilder buildSearchQuery()
	{
		string table_name = static::getTableName();
		QueryBuilder q = new QueryBuilder{ "_found_rows": true }
			.select( table_name )
			.page( this.page, this.limit )
			.order( this.getDefaultOrder() )
		;
		return q;
	}
	
	
	
	/**
	 * Search query before
	 */
	async bool searchQueryBefore()
	{
		return true;
	}
	
	
	
	/**
	 * Search query
	 */
	async void searchQuery()
	{
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Build query */
		QueryBuilder q = this.buildSearchQuery();
		
		/* Execute query */
		Cursor cursor = orm.execute(q);
		
		/* Get result */
		Vector items = new Vector();
		while (true)
		{
			Dict row = await cursor.fetch();
			if (row == null)
			{
				break;
			}
			row = await this.fromDatabase(row);
			row = await this.processItem(row);
			items.push(row);
		}
		
		this.q = q;
		this.items = items.toCollection();
		this.total = await cursor.foundRows();
		this.pages = (this.limit > 0) ? rtl::ceil(this.total / this.limit) : 0;
		
		await cursor.close();
	}
	
	
	
	/**
	 * Search
	 */
	async void search()
	{
		/* Validate */
		await this.validate();
		
		/* Can query */
		bool res = await this.searchQueryBefore();
		if (res)
		{
			/* Search query */
			await this.searchQuery();
			
			/* Process items */
			await this.processItems();
			
			/* Set success */
			this.is_success = true;
		}
		
		/* Create response */
		Dict response =
		{
			"filter": this.filter,
			"items": this.items,
			"page": this.page,
			"limit": this.limit,
			"total": this.total,
			"pages": this.pages,
		};
		this.answer = this.answer::success(this.answer, response);
	}
	
	
	
	/**
	 * Search api action
	 */
	static async list searchAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "search";
		api.answer = answer;
		api.request = request;
		api.page = request.data["page"] |> default int 0;
		api.limit = request.data["limit"] |> default int api.getDefaultLimit();
		if (api.limit > api.getMaxLimit()) api.limit = api.getMaxLimit();
		
		/* Init api */
		await api.init();
		
		/* Search */
		await api.search();
		
		/* After query */
		await api.after();
		
		return [request, api.answer];
	}
	
	
	
	/**
	 * Create query before
	 */
	async bool createQueryBefore()
	{
		return true;
	}
	
	
	
	/**
	 * Create query
	 */
	async void createQuery()
	{
		string table_name = static::getTableName();
		
		/* Convert item */
		Dict item = await this.convertItem(this.item);
		
		/* To database */
		item = this.toDatabase(item);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.insert(table_name, item);
		int id = await cursor.lastInsertId();
		await cursor.close();
		
		/* Process item */
		Map pk = new Map();
		Collection<FieldInfo> settings = this.getStruct();
		settings = settings.filter( lib::equalAttr("primary", true) );
		for (int i=0; i < settings.count(); i++)
		{
			FieldInfo field = settings[i];
			var value = item[field.api_name];
			if (field.auto_increment) value = id;
			pk.set(field.api_name, value);
		}
		this.pk = pk.toDict();
		this.new_item = await this.getByPrimaryKey(this.pk);
	}
	
	
	
	/**
	 * Create
	 */
	async void create()
	{
		/* Validate */
		await this.validate();
		
		/* Can query */
		bool res = await this.createQueryBefore();
		if (res)
		{
			/* Create query */
			await this.createQuery();
			this.is_success = true;
		}
		
		/* Process item */
		Dict new_item = null;
		if (this.new_item)
		{
			new_item = await this.processItem(this.new_item);
		}
		
		/* Create response */
		Dict response =
		{
			"pk": this.pk,
			"item": this.item,
			"new_item": new_item,
		};
		this.answer = this.answer::success(this.answer, response);
	}
	
	
	
	/**
	 * Create api action
	 */
	static async list createAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "create";
		api.answer = answer;
		api.request = request;
		api.item = request.data["item"] |> default Dict {};
		
		/* Init api */
		await api.init();
		
		/* Create */
		await api.create();
		
		/* After query */
		await api.after();
		
		return [request, api.answer];
	}
	
	
	
	/**
	 * Update query before
	 */
	async bool updateQueryBefore()
	{
		return true;
	}
	
	
	
	/**
	 * Update query
	 */
	async void updateQuery()
	{
		Dict pk = this.pk;
		Dict item = this.item;
		
		Collection keys = item.keys();
		if (keys.count() == 0)
		{
			return false;
		}
		
		string table_name = static::getTableName();
		
		/* Convert item */
		pk = await this.convertPrimaryKey(pk);
		item = await this.convertItem(item);
		
		/* Process item */
		item = this.toDatabase(item);
		
		/* Process primary key */
		pk = this.toDatabase(pk);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.update(table_name, pk, item);
		await cursor.close();
		
		/* Set new item */
		this.pk = this.getPrimaryKeyFromItem(this.item);
		this.new_item = await this.getByPrimaryKey(this.pk);
	}
	
	
	
	/**
	 * Update
	 */
	async void update()
	{
		/* Validate */
		await this.validate();
		
		/* Find item */
		this.old_item = await this.getByPrimaryKey(this.pk);
		this.new_item = this.old_item;
		if (this.old_item == null)
		{
			throw new ApiException
			(
				_("Runtime.Web.CRUD", "Item not found"),
				rtl::ERROR_ITEM_NOT_FOUND
			);
		}
		
		/* Can query */
		bool res = await this.updateQueryBefore();
		if (res)
		{
			/* Update query */
			await this.updateQuery();
			this.is_success = true;
		}
		
		/* Process item */
		Dict new_item = null, old_item = null;
		old_item = await this.processItem(this.old_item);
		if (this.new_item != this.old_item and this.new_item != null)
		{
			new_item = await this.processItem(this.new_item);
		}
		else
		{
			new_item = old_item;
		}
		
		Dict response =
		{
			"pk": this.pk,
			"item": this.item,
			"new_item": new_item,
			"old_item": old_item,
		};
		this.answer = this.answer::success(this.answer, response);
	}
	
	
	
	/**
	 * Update api action
	 */
	static async list updateAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "update";
		api.answer = answer;
		api.request = request;
		api.pk = request.data["pk"] |> default Dict {};
		api.item = request.data["item"] |> default Dict {};
		
		/* Init api */
		await api.init();
		
		/* Update */
		await api.update();
		
		/* After query */
		await api.after();
		
		return [request, api.answer];
	}
	
	
	
	/**
	 * Delete query before
	 */
	async bool deleteQueryBefore()
	{
		return true;
	}
	
	
	
	/**
	 * Delete query
	 */
	async void deleteQuery()
	{
		Dict pk = this.pk;
		string table_name = static::getTableName();
		
		/* Process primary key */
		pk = await this.convertPrimaryKey(pk);
		pk = this.toDatabase(pk);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.delete(table_name, pk);
		await cursor.close();
	}
	
	
	
	/**
	 * Update
	 */
	async void delete()
	{
		/* Init api */
		await this.init();
		
		/* Validate */
		await this.validate();
		
		/* Find item */
		this.old_item = await this.getByPrimaryKey(this.pk);
		if (this.old_item == null)
		{
			throw new ApiException("Item not found", rtl::ERROR_ITEM_NOT_FOUND);
		}
		
		/* Can query */
		bool res = await this.deleteQueryBefore();
		if (res)
		{
			/* Update query */
			await this.deleteQuery();
			this.is_success = true;
		}
		
		/* Create response */
		Dict old_item = await this.processItem(this.old_item);
		Dict response =
		{
			"pk": this.pk,
			"item": old_item,
		};
		this.answer = this.answer::success(this.answer, response);
	}
	
	
	
	/**
	 * Delete api action
	 */
	static async list deleteAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "delete";
		api.answer = answer;
		api.request = request;
		api.pk = request.data["pk"] |> default Dict {};
		
		/* Init api */
		await api.init();
		
		/* Delete */
		await api.delete();
		
		/* After query */
		await api.after();
		
		return [request, api.answer];
	}
	
}