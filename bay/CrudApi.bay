/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web.CRUD;

use Runtime.rtl;
use Runtime.lib;
use Runtime.BaseObject;
use Runtime.Core.ApiException;
use Runtime.Core.RemoteCallAnswer;
use Runtime.Core.RemoteCallRequest;
use Runtime.ORM.CursorInterface as Cursor;
use Runtime.ORM.DriverInterface as ORMDriver;
use Runtime.ORM.QueryBuilder;
use Runtime.Web.Backend.ApiList;
use Runtime.Web.Backend.ApiMethod;
use Runtime.Web.CRUD.CrudApi;
use Runtime.Web.CRUD.FieldInfo;


class CrudApi extends BaseObject
{
	string action = "";
	RemoteCallAnswer answer = null;
	RemoteCallRequest request = null;
	Collection<FieldInfo> struct = null;
	Dict foreigns = {};
	
	/* Search */
	Dict find = null;
	QueryBuilder q = null;
	int page = 0;
	int pages = 0;
	int total = 0;
	int limit = 100;
	Collection<Dict> items = null;
	
	/* Save */
	Map<Vector<string>> fields_errors = new Map();
	Dict pk = null;
	Dict item = null;
	Dict new_item = null;
	Dict old_item = null;
	bool is_success = false;
	
	
	
	/**
	 * Returns crud table name
	 */
	pure string getTableName() => "";
	
	
	
	/**
	 * Returns crud table name
	 */
	bool isSuccess() => this.is_success;
	
	
	
	/**
	 * Returns true if request is search
	 */
	bool isSearch() => this.action == "search";
	
	
	
	/**
	 * Returns true if request is create
	 */
	bool isCreate() => this.action == "create";
	
	
	
	/**
	 * Returns true if request is update
	 */
	bool isUpdate() => this.action == "update";
	
	
	
	/**
	 * Returns true if request is delete
	 */
	bool isDelete() => this.action == "delete";
	
	
	
	/**
	 * Is crud request
	 */
	bool isCRUD() =>
		this.action == "search" or
		this.action == "create" or
		this.action == "update" or
		this.action == "delete"
	;
	
	
	
	/**
	 * Returns table field value
	 */
	Collection<FieldInfo> settings() => [];
	
	
	
	/**
	 * Returns struct
	 */
	Collection<FieldInfo> getStruct()
	{
		if (this.struct == null) this.struct = this.settings();
		return this.struct;
	}
	
	
	
	/**
	 * Returns table field value
	 */
	Collection<Collection<string>> getDefaultOrder() =>
	[
		["id", "desc"]
	];
	
	
	
	/**
	 * Returns default limit
	 */
	int getDefaultLimit() => 10;
	
	
	
	/**
	 * Returns maximum limit
	 */
	Collection<Collection<string>> getMaxLimit() => 1000;
	
	
	
	/**
	 * Returns primary key by item
	 */
	Dict getPrimaryKeyFromItem(Dict item)
	{
		Map pk = new Map();
		Collection<FieldInfo> settings = this.getStruct();
		settings = settings.filter( lib::equalAttr("primary", true) );
		for (int i=0; i < settings.count(); i++)
		{
			FieldInfo field = settings[i];
			var value = item[field.api_name];
			pk.set(field.api_name, value);
		}
		return pk.toDict();
	}
	
	
	
	/**
	 * Convert primare key before query
	 */
	async Dict convertPrimaryKey(Dict pk)
	{
		return pk;
	}
	
	
	
	/**
	 * Convert item before save to database
	 */
	async Dict convertItem(Dict item)
	{
		Collection<FieldInfo> settings = this.getStruct();
		Dict item_keys = item.keys();
		
		for (int i=0; i<settings.count(); i++)
		{
			FieldInfo field = settings[i];
			string key = field.api_name;
			var value = item[field.api_name];
			
			/* Remove readonly key */
			bool readonly = field["readonly"] |> default bool false;
			if (readonly)
			{
				item = item.removeIm(key);
				continue;
			}
			
			/* Remove virtual key */
			bool virtual = field["virtual"] |> default bool false;
			if (virtual)
			{
				item = item.removeIm(key);
				continue;
			}
			
			/* Can create */
			bool can_create = field["can_create"] |> default bool false;
			if (this.action == "create" and not can_create)
			{
				item = item.removeIm(key);
				continue;
			}
			
			/* Can update */
			bool can_update = field["can_update"] |> default bool false;
			if (this.action == "update" and not can_update)
			{
				item = item.removeIm(key);
				continue;
			}
			
			/* Set default value */
			var default_value = field["default"] |> default bool false;
			if (rtl::isEmpty(value))
			{
				item = rtl::setAttr(item, field.api_name, default_value);
			}
		}
		
		for (int i=0; i<item_keys.count(); i++)
		{
			string key = item_keys[i];
			FieldInfo field = FieldInfo::getFieldInfo(settings, key);
			
			/* Remove if key does not exists */
			if (field == null)
			{
				item = item.removeIm(key);
				continue;
			}
		}
		
		return item;
	}
	
	
	
	/**
	 * Process item from database
	 */
	async Dict fromDatabase(Dict item)
	{
		return item;
	}
	
	
	
	/**
	 * Process item to database
	 */
	async Dict toDatabase(Dict item)
	{
		return item;
	}
	
	
	
	/**
	 * Init request
	 */
	async void init()
	{
	}
	
	
	
	/**
	 * Before query
	 */
	async bool beforeQuery()
	{
		if (this.action == "search")
		{
		}
		else if (this.action == "create")
		{
		}
		else if (this.action == "update")
		{
		}
		else if (this.action == "delete")
		{
		}
	}
	
	
	
	/**
	 * After query
	 */
	async bool afterQuery()
	{
		if (this.action == "search")
		{
			for (int i=0; i<this.items.count(); i++)
			{
				Dict row = this.items[i];
				static::foreignItem(row);
			}
		}
		else if (this.action == "create")
		{
			static::foreignItem(this.new_item);
		}
		else if (this.action == "update")
		{
			static::foreignItem(this.old_item);
			static::foreignItem(this.new_item);
		}
		else if (this.action == "delete")
		{
			static::foreignItem(this.old_item);
		}
		
		await static::foreignRequest();
	}
	
	
	
	/**
	 * Analyze item for foreign keys
	 */
	void foreignItem(Dict item)
	{
		Dict foreigns = this.foreigns;
		Collection<FieldInfo> settings = this.getStruct();
		
		/* Get id from primary key */
		Dict pk = this.getPrimaryKeyFromItem(item);
		
		/* Push primary key */
		for (int i=0; i<settings.count(); i++)
		{
			FieldInfo field = settings[i];
			if (field.foreign == null) continue;
			
			string foreign_type = field.foreign["type"];
			string foreign_name = field.foreign["name"];
			string foreign_key = field.foreign["key"];
			if (rtl::isEmpty(foreign_name))
			{
				continue;
			}
			
			if (not foreigns.has(foreign_name))
			{
				foreigns = foreigns.setIm
				(
					foreign_name,
					{
						"field": field,
						"keys": [],
					}
				);
			}
			
			if (foreign_type == "one_to_many")
			{
				Dict foreign_item = null;
				var foreign_value = item[foreign_key];
				Collection arr = foreigns[foreign_name]["keys"];
				int pos = arr.indexOf(foreign_value);
				if (pos == -1)
				{
					foreigns <= { foreign_name } <= "keys" <= arr.pushIm(foreign_value);
				}
			}
			if (foreign_type == "many_to_many")
			{
				Collection arr = foreigns[foreign_name]["keys"];
				foreigns <= { foreign_name } <= "keys" <= arr.pushIm(pk);
			}
		}
		
		this.foreigns = foreigns;
	}
	
	
	
	/**
	 * Request foreign keys
	 */
	async void foreignRequest()
	{
		ORMDriver orm = @.getDriver(classof ORMDriver);
		Collection<FieldInfo> settings = this.getStruct();
		
		/* Get primary field */
		Collection<FieldInfo> primary_settings = settings.filter( lib::equalAttr("primary", true) );
		FieldInfo primary_field = primary_settings[0];
		string primary_api_name = primary_field["api_name"];
		
		/* Load foreign keys */
		for (int i=0; i<settings.count(); i++)
		{
			FieldInfo field = settings[i];
			string field_api_name = field["api_name"];
			if (field.foreign != null)
			{
				/* Load dictionary */
				string foreign_name = field.foreign["name"];
				bool load_dictionary = field.foreign["load_dictionary"] |> default bool true;
				if (load_dictionary and rtl::isEmpty(this.foreigns[foreign_name, "items"]))
				{
					string class_name = field.foreign["class_name"];
					if (foreign_name != null and class_name != null)
					{
						fn f = rtl::method(class_name, "search");
						Collection items = await f() |> attr "items";
						this.foreigns = rtl::setAttr(this.foreigns, [foreign_name, "items"], items);
					}
				}
				
				/* Load many to many keys */
				string foreign_type = field.foreign["type"];
				string subtable = field["foreign", "subtable"];
				string key_subtable = field["foreign", "key_subtable"];
				string key_subtable2 = field["foreign", "key_subtable2"];
				bool load_many_to_many = field.foreign["load_many_to_many"] |> default bool true;
				bool save_many_to_many = field.foreign["save_many_to_many"] |> default bool true;
				Collection foreign_keys = this.foreigns[foreign_name, "keys"];
				if
				(
					load_many_to_many and
					foreign_type == "many_to_many" and
					not rtl::isEmpty(subtable) and
					not rtl::isEmpty(key_subtable) and
					not rtl::isEmpty(foreign_keys)
				)
				{
					foreign_keys = foreign_keys.map( lib::attr(primary_api_name) );
					
					/* Build filter */
					Map<string> filter = new Map();
					filter.set(key_subtable, foreign_keys);
					
					/* ORM select */
					Cursor cursor = await orm.select(subtable, filter.toDict());
					Dict foreign_items = await cursor.fetchAll();
					await cursor.close();
					
					/* Save foreign keys */
					if (save_many_to_many and (this.action == "create" or this.action == "update"))
					{
						Collection new_items = this.item[field_api_name] |> default Collection null;
						
						/* Insert or update */
						if (new_items != null)
						{
							for (int j=0; j<new_items.count(); j++)
							{
								Dict new_item = new_items[j];
								Dict new_item_pk = new Map();
								new_item_pk.set(key_subtable, new_item[key_subtable]);
								new_item_pk.set(key_subtable2, new_item[key_subtable2]);
								new_item_pk = new_item_pk.toDict();
								
								if (rtl::isEmpty(new_item_pk[key_subtable]))
								{
									continue;
								}
								if (new_item_pk[key_subtable] != this.new_item[primary_api_name])
								{
									continue;
								}
								
								int index = foreign_items.find
								(
									bool (Dict foreign_item) use (new_item, key_subtable, key_subtable2) =>
										new_item[key_subtable] != null and
										new_item[key_subtable2] != null and
										new_item[key_subtable] == foreign_item[key_subtable] and
										new_item[key_subtable2] == foreign_item[key_subtable2]
								);
								
								/* Query */
								Dict new_item_update = new_item;
								new_item_update = new_item_update.removeIm(key_subtable);
								new_item_update = new_item_update.removeIm(key_subtable2);
								await orm.insert_or_update(subtable, new_item_pk, new_item_update);
								
								/* Update foreign item */
								if (index == -1)
								{
									foreign_items = foreign_items.pushIm(new_item);
								}
								else
								{
									foreign_items = foreign_items.setIm(index, new_item);
								}
							}
						}
						
						/* Remove keys */
						for (int j=foreign_items.count() - 1; j>=0; j--)
						{
							Dict foreign_item = foreign_items[j];
							
							if (rtl::isEmpty(this.new_item[primary_api_name]))
							{
								continue;
							}
							if (foreign_item[key_subtable] != this.new_item[primary_api_name])
							{
								continue;
							}
							
							int index = new_items.find
							(
								bool (Dict new_item) use (foreign_item, key_subtable, key_subtable2) =>
									new_item[key_subtable] != null and
									new_item[key_subtable2] != null and
									new_item[key_subtable] == foreign_item[key_subtable] and
									new_item[key_subtable2] == foreign_item[key_subtable2]
							);
							
							Dict new_item_pk = new Map();
							new_item_pk.set(key_subtable, foreign_item[key_subtable]);
							new_item_pk.set(key_subtable2, foreign_item[key_subtable2]);
							
							/* Remove foreign item */
							if (index == -1)
							{
								await orm.delete(subtable, new_item_pk);
								foreign_items = foreign_items.removeIm(j);
							}
						}
						
					}
					
					this.foreigns = rtl::setAttr
					(
						this.foreigns,
						[foreign_name, "many_to_many"],
						foreign_items
					);
				}
			}
		}
	}
	
	
	
	/**
	 * Process item before response
	 */
	async Dict processItem(Dict item)
	{
		Collection<FieldInfo> settings = this.getStruct();
		
		/* Get primary field */
		Collection<FieldInfo> primary_settings = settings.filter( lib::equalAttr("primary", true) );
		FieldInfo primary_field = primary_settings[0];
		string primary_api_name = primary_field["api_name"];
		var primary_value = item[primary_api_name];
		
		Dict item_keys = item.keys();
		for (int i=0; i<settings.count(); i++)
		{
			FieldInfo field = settings[i];
			string api_name = field.api_name;
			
			/* Add value for virtual field */
			if (field.virtual)
			{
				/* Get foreign value */
				if (field.foreign != null)
				{
					string foreign_type = field.foreign["type"];
					string foreign_name = field.foreign["name"];
					string foreign_key = field.foreign["key"];
					string key_subtable = field.foreign["key_subtable"];
					if
					(
						not rtl::isEmpty(foreign_name) and
						not rtl::isEmpty(key_subtable)
					)
					{
						if (foreign_type == "one_to_many")
						{
							Dict foreign_item = null;
							var foreign_value = item[foreign_key];
							Collection options = this.foreigns[foreign_name, "items"];
							if (options != null)
							{
								foreign_item = options.findItem( lib::equalAttr(key_subtable, foreign_value) );
							}
							item <= { api_name } <= foreign_item;
						}
						if (foreign_type == "many_to_many")
						{
							Dict items = this.foreigns[foreign_name, "many_to_many"]
								|> lib::filter( lib::equalAttr(key_subtable, primary_value) )
							;
							item <= { api_name } <= items;
						}
					}
				}
			}
		}
		return item;
	}
	
	
	
	/**
	 * Process items
	 */
	async void processItems()
	{
		if (this.action == "search")
		{
			Vector new_items = new Vector();
			for (int i=0; i<this.items.count(); i++)
			{
				Dict row = this.items[i];
				row = await this.processItem(row);
				new_items.push(row);
			}
			this.items = new_items.toCollection();
		}
	}
	
	
	
	/**
	 * After
	 */
	async bool after()
	{
		if (this.isSuccess())
		{
			this.answer = rtl::setAttr(this.answer, ["response", "foreigns"], this.foreigns);
		}
	}
	
	
	
	/**
	 * Add error
	 */
	async bool addFieldError(string field_name, string error)
	{
		if (not this.fields_errors.has(field_name))
		{
			this.fields_errors.set(field_name, new Vector());
		}
		Vector<string> errors = this.fields_errors[field_name];
		errors.push(error);
	}
	
	
	
	/**
	 * Validate form
	 */
	async bool validateForm()
	{
		bool res = true;
		
		Collection<FieldInfo> settings = this.getStruct();
		for (int i=0; i<settings.count(); i++)
		{
			FieldInfo field = settings[i];
			var value = this.item[field.api_name];
			if (field == null) continue;
			
			bool required = field["required"] |> default bool false;
			if (required and rtl::isEmpty(value))
			{
				this.addFieldError( field.api_name, _("Runtime.Web.CRUD", "This field must be filled") );
				res = false;
			}
		}
		
		return res;
	}
	
	
	
	/**
	 * Validate
	 */
	async bool validate()
	{
		if (this.action == "add" or this.action == "update")
		{
			list res = await this.validateForm();
			if (not res)
			{
				throw new ApiException
				(
					_("Runtime.Web.CRUD", "Validation fields error"),
					rtl::ERROR_VALIDATION,
					{
						"fields_errors": this.fields_errors
					}
				);
			}
		}
	}
	
	
	
	/**
	 * Returns item by pk
	 */
	async Dict getByPrimaryKey(Dict pk)
	{
		Dict item = null;
		string table_name = static::getTableName();
		
		/* Process primary key */
		pk = await this.convertPrimaryKey(pk);
		if (pk != null)
		{
			pk = this.toDatabase(pk);
			
			/* Get ORM driver */
			ORMDriver orm = @.getDriver(classof ORMDriver);
			
			/* Create query */
			Cursor cursor = await orm.select(table_name, pk, 0, 1);
			Dict item = cursor.fetchOne();
			await cursor.close();
			
			/* From database */
			item = await this.fromDatabase(item);
		}
		return item;
	}
	
	
	
	/**
	 * Build query
	 */
	QueryBuilder buildSearchQuery()
	{
		string table_name = static::getTableName();
		QueryBuilder q = new QueryBuilder{ "_found_rows": true }
			.select( table_name )
			.page( this.page, this.limit )
			.order( this.getDefaultOrder() )
		;
		return q;
	}
	
	
	
	/**
	 * Search query before
	 */
	async bool canSearchQuery()
	{
		return true;
	}
	
	
	
	/**
	 * Search query
	 */
	async void searchQuery()
	{
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Build query */
		QueryBuilder q = this.buildSearchQuery();
		
		/* Execute query */
		Cursor cursor = orm.execute(q);
		
		/* Get result */
		Vector items = new Vector();
		while (true)
		{
			Dict row = await cursor.fetch();
			if (row == null)
			{
				break;
			}
			row = await this.fromDatabase(row);
			items.push(row);
		}
		
		this.q = q;
		this.items = items.toCollection();
		this.total = await cursor.foundRows();
		this.pages = (this.limit > 0) ? rtl::ceil(this.total / this.limit) : 0;
		
		await cursor.close();
	}
	
	
	
	/**
	 * Search
	 */
	async void doSearch()
	{
		/* Validate */
		await this.validate();
		
		/* Can query */
		bool res = await this.canSearchQuery();
		if (res)
		{
			/* Before query */
			await this.beforeQuery();
			
			/* Search query */
			await this.searchQuery();
			
			/* After query */
			await this.afterQuery();
			
			/* Process items */
			await this.processItems();
			
			/* Set success */
			this.is_success = true;
		}
		
		/* Create response */
		Dict response =
		{
			"filter": this.filter,
			"items": this.items,
			"page": this.page,
			"limit": this.limit,
			"total": this.total,
			"pages": this.pages,
		};
		this.answer = this.answer::success(this.answer, response);
	}
	
	
	
	/**
	 * Search api action
	 */
	static async list searchAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "search";
		api.answer = answer;
		api.request = request;
		api.page = request.data["page"] |> default int 0;
		api.limit = request.data["limit"] |> default int api.getDefaultLimit();
		if (api.limit > api.getMaxLimit()) api.limit = api.getMaxLimit();
		
		/* Init api */
		await api.init();
		
		/* Search */
		await api.doSearch();
		
		/* After query */
		await api.after();
		
		return [request, api.answer];
	}
	
	
	
	/**
	 * Search
	 */
	static async void search(Dict find = null)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "search";
		api.find = find;
		api.page = find["page"] |> default int 0;
		api.limit = find["limit"] |> default int -1;
		
		/* Query */
		await api.searchQuery();
		
		return
		{
			"items": api.items,
			"page": api.page,
			"pages": api.pages,
			"limit": api.limit,
			"total": api.total,
		};
	}
	
	
	
	/**
	 * Create query before
	 */
	async bool canCreateQuery()
	{
		return true;
	}
	
	
	
	/**
	 * Create query
	 */
	async void createQuery()
	{
		string table_name = static::getTableName();
		
		/* Convert item */
		Dict item = await this.convertItem(this.item);
		
		/* To database */
		item = this.toDatabase(item);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.insert(table_name, item);
		int id = await cursor.lastInsertId();
		await cursor.close();
		
		/* Process item */
		Map pk = new Map();
		Collection<FieldInfo> settings = this.getStruct();
		settings = settings.filter( lib::equalAttr("primary", true) );
		for (int i=0; i < settings.count(); i++)
		{
			FieldInfo field = settings[i];
			var value = item[field.api_name];
			if (field.auto_increment) value = id;
			pk.set(field.api_name, value);
		}
		this.pk = pk.toDict();
		this.new_item = await this.getByPrimaryKey(this.pk);
	}
	
	
	
	/**
	 * Create
	 */
	async void doCreate()
	{
		/* Validate */
		await this.validate();
		
		/* Can query */
		bool res = await this.canCreateQuery();
		if (res)
		{
			/* Before query */
			await this.beforeQuery();
			
			/* Create query */
			await this.createQuery();
			
			/* After query */
			await this.afterQuery();
			
			this.is_success = true;
		}
		
		/* Process item */
		Dict new_item = null;
		if (this.new_item)
		{
			new_item = await this.processItem(this.new_item);
		}
		
		/* Create response */
		Dict response =
		{
			"pk": this.pk,
			"item": this.item,
			"new_item": new_item,
		};
		this.answer = this.answer::success(this.answer, response);
	}
	
	
	
	/**
	 * Create api action
	 */
	static async list createAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "create";
		api.answer = answer;
		api.request = request;
		api.item = request.data["item"] |> default Dict {};
		
		/* Init api */
		await api.init();
		
		/* Create */
		await api.doCreate();
		
		/* After query */
		await api.after();
		
		return [request, api.answer];
	}
	
	
	
	/**
	 * Create
	 */
	static async void create(Dict item)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "create";
		api.item = item;
		
		/* Query */
		await api.createQuery();
		
		return api.new_item;
	}
	
	
	
	/**
	 * Update query before
	 */
	async bool canUpdateQuery()
	{
		return true;
	}
	
	
	
	/**
	 * Update query
	 */
	async void updateQuery()
	{
		Dict pk = this.pk;
		Dict item = this.item;
		
		Collection keys = item.keys();
		if (keys.count() == 0)
		{
			return false;
		}
		
		string table_name = static::getTableName();
		
		/* Convert item */
		pk = await this.convertPrimaryKey(pk);
		item = await this.convertItem(item);
		
		/* Process item */
		item = this.toDatabase(item);
		
		/* Process primary key */
		pk = this.toDatabase(pk);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.update(table_name, pk, item);
		await cursor.close();
		
		/* Set new item */
		this.pk = this.getPrimaryKeyFromItem(this.item);
		this.new_item = await this.getByPrimaryKey(this.pk);
	}
	
	
	
	/**
	 * Update
	 */
	async void doUpdate()
	{
		/* Validate */
		await this.validate();
		
		/* Find item */
		this.old_item = await this.getByPrimaryKey(this.pk);
		this.new_item = this.old_item;
		if (this.old_item == null)
		{
			throw new ApiException
			(
				_("Runtime.Web.CRUD", "Item not found"),
				rtl::ERROR_ITEM_NOT_FOUND
			);
		}
		
		/* Can query */
		bool res = await this.canUpdateQuery();
		if (res)
		{
			/* Before query */
			await this.beforeQuery();
			
			/* Update query */
			await this.updateQuery();
			
			/* After query */
			await this.afterQuery();
			
			this.is_success = true;
		}
		
		/* Process item */
		Dict new_item = null, old_item = null;
		old_item = await this.processItem(this.old_item);
		if (this.new_item != this.old_item and this.new_item != null)
		{
			new_item = await this.processItem(this.new_item);
		}
		else
		{
			new_item = old_item;
		}
		
		Dict response =
		{
			"pk": this.pk,
			"item": this.item,
			"new_item": new_item,
			"old_item": old_item,
		};
		this.answer = this.answer::success(this.answer, response);
	}
	
	
	
	/**
	 * Update api action
	 */
	static async list updateAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "update";
		api.answer = answer;
		api.request = request;
		api.pk = request.data["pk"] |> default Dict {};
		api.item = request.data["item"] |> default Dict {};
		
		/* Init api */
		await api.init();
		
		/* Update */
		await api.doUpdate();
		
		/* After query */
		await api.after();
		
		return [request, api.answer];
	}
	
	
	
	/**
	 * Update
	 */
	static async void update(Dict pk, Dict item)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "update";
		api.pk = pk;
		api.item = item;
		
		/* Query */
		await api.updateQuery();
		
		return api.new_item;
	}
	
	
	
	/**
	 * Delete query before
	 */
	async bool canDeleteQuery()
	{
		return true;
	}
	
	
	
	/**
	 * Delete query
	 */
	async void deleteQuery()
	{
		Dict pk = this.pk;
		string table_name = static::getTableName();
		
		/* Process primary key */
		pk = await this.convertPrimaryKey(pk);
		pk = this.toDatabase(pk);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.delete(table_name, pk);
		await cursor.close();
	}
	
	
	
	/**
	 * Update
	 */
	async void doDelete()
	{
		/* Init api */
		await this.init();
		
		/* Validate */
		await this.validate();
		
		/* Find item */
		this.old_item = await this.getByPrimaryKey(this.pk);
		if (this.old_item == null)
		{
			throw new ApiException("Item not found", rtl::ERROR_ITEM_NOT_FOUND);
		}
		
		/* Can query */
		bool res = await this.canDeleteQuery();
		if (res)
		{
			/* Before query */
			await this.beforeQuery();
			
			/* Update query */
			await this.deleteQuery();
			
			/* After query */
			await this.afterQuery();
			
			this.is_success = true;
		}
		
		/* Create response */
		Dict old_item = await this.processItem(this.old_item);
		Dict response =
		{
			"pk": this.pk,
			"item": old_item,
		};
		this.answer = this.answer::success(this.answer, response);
	}
	
	
	
	/**
	 * Delete api action
	 */
	static async list deleteAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "delete";
		api.answer = answer;
		api.request = request;
		api.pk = request.data["pk"] |> default Dict {};
		
		/* Init api */
		await api.init();
		
		/* Delete */
		await api.doDelete();
		
		/* After query */
		await api.after();
		
		return [request, api.answer];
	}
	
	
	
	/**
	 * Delete
	 */
	static async void delete(Dict pk)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "delete";
		api.pk = pk;
		
		/* Query */
		await api.deleteQuery();
		
		return api.new_item;
	}
}