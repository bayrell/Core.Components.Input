/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web.CRUD;

use Runtime.rtl;
use Runtime.BaseObject;
use Runtime.Core.ApiException;
use Runtime.Core.RemoteCallAnswer;
use Runtime.Core.RemoteCallRequest;
use Runtime.ORM.CursorInterface as Cursor;
use Runtime.ORM.DriverInterface as ORMDriver;
use Runtime.ORM.QueryBuilder;
use Runtime.Web.Backend.ApiList;
use Runtime.Web.Backend.ApiMethod;
use Runtime.Web.CRUD.CrudApi;


class CrudApi extends BaseObject
{
	string action = "";
	RemoteCallAnswer answer = null;
	RemoteCallRequest request = null;
	
	/* Search */
	var filter = null;
	QueryBuilder q = null;
	int page = 0;
	int pages = 0;
	int total = 0;
	int limit = 100;
	Collection<Dict> items = null;
	
	/* Save */
	Map<Vector<string>> fields_errors = new Map();
	Dict pk = null;
	Dict item = null;
	Dict new_item = null;
	Dict old_item = null;
	
	
	/**
	 * Returns crud table name
	 */
	pure string getTableName() => "";
	
	
	
	/**
	 * Returns table field value
	 */
	Collection<Collection<string>> getDefaultOrder() =>
	[
		["id", "desc"]
	];
	
	
	
	/**
	 * Returns default limit
	 */
	int getDefaultLimit() => 10;
	
	
	
	/**
	 * Returns maximum limit
	 */
	Collection<Collection<string>> getMaxLimit() => 1000;
	
	
	
	/**
	 * Init request
	 */
	async void init()
	{
	}
	
	
	
	/**
	 * Process item before response
	 */
	async Dict processItem(Dict item)
	{
		return item;
	}
	
	
	
	/**
	 * Process items
	 */
	async void processItems()
	{
	}
	
	
	
	/**
	 * Convert primare key before query
	 */
	async Dict convertPrimaryKey(Dict pk)
	{
		return pk;
	}
	
	
	
	/**
	 * Convert item before save to database
	 */
	async Dict convertItem(Dict item)
	{
		Dict settings = this.settings();
		Dict settings_keys = settings.keys();
		Dict item_keys = item.keys();
		
		for (int i=0; i<settings_keys.count(); i++)
		{
			string key = settings_keys[i];
			var value = item[key];
			Dict field = settings[key];
			
			/* Set default value */
			var default_value = field["default"] |> default bool false;
			if (rtl::isEmpty(value))
			{
				item = rtl::setAttr(item, key, default_value);
			}
		}
		
		for (int i=0; i<item_keys.count(); i++)
		{
			string key = item_keys[i];
			
			/* Remove if key does not exists */
			if (not settings.has(key))
			{
				item = item.removeIm(key);
			}
			Dict field = settings[key];
			
			/* Remove readonly key */
			bool readonly = field["readonly"] |> default bool false;
			if (readonly)
			{
				item = item.removeIm(key);
			}
		}
		
		return item;
	}
	
	
	
	/**
	 * Process item from database
	 */
	async Dict fromDatabase(Dict item)
	{
		return item;
	}
	
	
	
	/**
	 * Process item to database
	 */
	async Dict toDatabase(Dict item)
	{
		return item;
	}
	
	
	
	/**
	 * Add error
	 */
	async bool addFieldError(string field_name, string error)
	{
		if (not this.fields_errors.has(field_name))
		{
			this.fields_errors.set(field_name, new Vector());
		}
		Vector<string> errors = this.fields_errors[field_name];
		errors.push(error);
	}
	
	
	
	/**
	 * Validate form
	 */
	async bool validateForm()
	{
		bool res = true;
		
		Dict settings = this.settings();
		Dict keys = settings.keys();
		
		for (int i=0; i<keys.count(); i++)
		{
			string key = keys[i];
			var value = this.item[key];
			if (not settings.has(key)) continue;
			
			Dict field = settings[key];
			bool required = field["required"] |> default bool false;
			if (required and rtl::isEmpty(value))
			{
				this.addFieldError( key, _("Runtime.Web.CRUD", "This field must be filled") );
				res = false;
			}
		}
		
		return res;
	}
	
	
	
	/**
	 * Validate
	 */
	async bool validate()
	{
		if (this.action == "add" or this.action == "update")
		{
			list res = await this.validateForm();
			if (not res)
			{
				throw new ApiException
				(
					_("Runtime.Web.CRUD", "Validation fields error"),
					rtl::ERROR_VALIDATION,
					{
						"fields_errors": this.fields_errors
					}
				);
			}
		}
	}
	
	
	
	/**
	 * After
	 */
	async bool after()
	{
	}
	
	
	
	/**
	 * Build query
	 */
	QueryBuilder buildSearchQuery()
	{
		string table_name = static::getTableName();
		QueryBuilder q = new QueryBuilder{ "_found_rows": true }
			.select( table_name )
			.page( this.page, this.limit )
			.order( this.getDefaultOrder() )
		;
		return q;
	}
	
	
	
	/**
	 * Search query before
	 */
	async bool searchQueryBefore()
	{
		return true;
	}
	
	
	
	/**
	 * Search query
	 */
	async void searchQuery()
	{
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Build query */
		QueryBuilder q = this.buildSearchQuery();
		
		/* Execute query */
		Cursor cursor = orm.execute(q);
		
		/* Get result */
		Vector items = new Vector();
		while (true)
		{
			Dict row = await cursor.fetch();
			if (row == null)
			{
				break;
			}
			row = await this.fromDatabase(row);
			row = await this.processItem(row);
			items.push(row);
		}
		
		this.q = q;
		this.items = items.toCollection();
		this.total = await cursor.foundRows();
		this.pages = (this.limit > 0) ? rtl::ceil(this.total / this.limit) : 0;
		
		await cursor.close();
	}
	
	
	
	/**
	 * Create query before
	 */
	async bool createQueryBefore()
	{
		this.new_item = await this.convertItem(this.new_item);
		return true;
	}
	
	
	
	/**
	 * Create query
	 */
	async var createQuery(Dict item)
	{
		string table_name = static::getTableName();
		
		/* To database */
		item = this.toDatabase(item);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.insert(table_name, item);
		int id = await cursor.lastInsertId();
		await cursor.close();
		
		return id;
	}
	
	
	
	/**
	 * Update query before
	 */
	async bool updateQueryBefore()
	{
		this.pk = await this.convertPrimaryKey(this.pk);
		this.new_item = await this.convertItem(this.new_item);
		return true;
	}
	
	
	
	/**
	 * Update query
	 */
	async void updateQuery(Dict pk, Dict item)
	{
		string table_name = static::getTableName();
		
		/* Process item */
		item = this.toDatabase(item);
		
		/* Process primary key */
		pk = this.toDatabase(pk);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.update(table_name, pk, item);
		await cursor.close();
	}
	
	
	
	/**
	 * Delete query before
	 */
	async bool deleteQueryBefore()
	{
		this.pk = await this.convertPrimaryKey(this.pk);
		return true;
	}
	
	
	
	/**
	 * Delete query
	 */
	async void deleteQuery(Dict pk)
	{
		string table_name = static::getTableName();
		
		/* Process primary key */
		pk = this.toDatabase(pk);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.delete(table_name, pk);
		await cursor.close();
	}
	
	
	
	/**
	 * Returns item by pk
	 */
	async Dict getByPrimaryKey(Dict pk)
	{
		string table_name = static::getTableName();
		
		/* Process primary key */
		pk = await this.convertPrimaryKey(pk);
		pk = this.toDatabase(pk);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.select(table_name, pk, 0, 1);
		Dict item = cursor.fetchOne();
		await cursor.close();
		
		return item;
	}
	
	
	
	/**
	 * Search api action
	 */
	static async list searchAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "search";
		api.request = request;
		api.page = request.data["page"] |> default int 0;
		api.limit = request.data["limit"] |> default int api.getDefaultLimit();
		if (api.limit > api.getMaxLimit()) api.limit = api.getMaxLimit();
		
		/* Init api */
		await api.init();
		
		/* Validate */
		await api.validate();
		
		/* Can query */
		bool res = await api.searchQueryBefore();
		if (not res)
		{
			return [request, api.answer];
		}
		
		/* Search query */
		await api.searchQuery();
		
		/* Process items */
		await api.processItems();
		
		/* Create response */
		Dict response =
		{
			"filter": api.filter,
			"items": api.items,
			"page": api.page,
			"limit": api.limit,
			"total": api.total,
			"pages": api.pages,
		};
		api.answer = answer::success(answer, response);
		
		/* After query */
		await api.after();
		
		return [request, api.answer];
	}
	
	
	
	/**
	 * Add api action
	 */
	static async list addAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "add";
		api.answer = answer;
		api.request = request;
		api.item = request.data["item"] |> default Dict {};
		api.new_item = api.item;
		
		/* Init api */
		await api.init();
		
		/* Validate */
		await api.validate();
		
		/* Can query */
		bool res = await api.createQueryBefore();
		if (not res)
		{
			return [request, api.answer];
		}
		
		/* Create query */
		var id = await api.createQuery(api.new_item);
		
		/* Process item */
		api.pk =
		{
			"id": id,
		};
		api.new_item = await api.getByPrimaryKey(api.pk);
		api.new_item = await api.processItem(api.new_item);
		
		/* Create response */
		Dict response =
		{
			"pk": api.pk,
			"item": api.item,
			"new_item": api.new_item,
		};
		api.answer = answer::success(answer, response);
		
		/* After query */
		await api.after();
		
		return [request, api.answer];
	}
	
	
	
	/**
	 * Update api action
	 */
	static async list updateAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "update";
		api.answer = answer;
		api.request = request;
		api.pk = request.data["pk"] |> default Dict {};
		api.item = request.data["item"] |> default Dict {};
		api.new_item = api.item;
		
		/* Init api */
		await api.init();
		
		/* Validate */
		await api.validate();
		
		/* Find item */
		api.old_item = await api.getByPrimaryKey(api.pk);
		if (api.old_item == null)
		{
			throw new ApiException
			(
				_("Runtime.Web.CRUD", "Item not found"),
				rtl::ERROR_ITEM_NOT_FOUND
			);
		}
		
		/* Can query */
		bool res = await api.updateQueryBefore();
		if (not res)
		{
			return [request, api.answer];
		}
		
		/* Update query */
		await api.updateQuery(api.pk, api.new_item);
		
		/* Create response */
		api.new_item = await api.getByPrimaryKey(api.pk);
		api.new_item = await api.processItem(api.new_item);
		api.old_item = await api.processItem(api.old_item);
		Dict response =
		{
			"pk": api.pk,
			"item": api.item,
			"new_item": api.new_item,
			"old_item": api.old_item,
		};
		api.answer = answer::success(answer, response);
		
		/* After query */
		await api.after();
		
		return [request, api.answer];
	}
	
	
	
	/**
	 * Delete api action
	 */
	static async list deleteAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "delete";
		api.answer = answer;
		api.request = request;
		api.pk = request.data["pk"] |> default Dict {};
		
		/* Init api */
		await api.init();
		
		/* Validate */
		await api.validate();
		
		/* Find item */
		api.old_item = await api.getByPrimaryKey(api.pk);
		if (api.old_item == null)
		{
			throw new ApiException("Item not found", rtl::ERROR_ITEM_NOT_FOUND);
		}
		
		/* Can query */
		bool res = await api.deleteQueryBefore();
		if (not res)
		{
			return [request, api.answer];
		}
		
		/* Update query */
		await api.deleteQuery(api.pk);
		
		/* Create response */
		api.old_item = await api.processItem(api.old_item);
		Dict response =
		{
			"pk": api.pk,
			"item": api.old_item,
		};
		api.answer = answer::success(answer, response);
		
		/* After query */
		await api.after();
		
		return [request, api.answer];
	}
	
}