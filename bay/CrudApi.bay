/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web.CRUD;

use Runtime.rtl;
use Runtime.BaseObject;
use Runtime.Core.ApiException;
use Runtime.Core.RemoteCallAnswer;
use Runtime.Core.RemoteCallRequest;
use Runtime.ORM.CursorInterface as Cursor;
use Runtime.ORM.DriverInterface as ORMDriver;
use Runtime.ORM.QueryBuilder;
use Runtime.Web.Backend.ApiList;
use Runtime.Web.Backend.ApiMethod;
use Runtime.Web.CRUD.CrudApi;


class CrudApi extends BaseObject
{
	string action = "";
	RemoteCallRequest request = null;
	
	
	/**
	 * Returns crud table name
	 */
	string getTableName() => "";
	
	
	
	/**
	 * Init request
	 */
	async void init()
	{
	}
	
	
	
	/**
	 * Process item from database
	 */
	async Dict fromDatabase(Dict item)
	{
		return item;
	}
	
	
	
	/**
	 * Process item to database
	 */
	async Dict toDatabase(Dict item)
	{
		return item;
	}
	
	
	
	/**
	 * Process item to output
	 */
	async Dict processItem(Dict item)
	{
		return item;
	}
	
	
	
	/**
	 * Process items to output
	 */
	async Collection<Dict> processItems(Collection<Dict> items)
	{
		return items;
	}
	
	
	
	/**
	 * Convert primare key before query
	 */
	async Dict convertPrimaryKey(Dict pk)
	{
		return pk;
	}
	
	
	
	/**
	 * Convert item before query
	 */
	async Dict convertItem(Dict item)
	{
		item = item.removeIm("id");
		return item;
	}
	
	
	
	/**
	 * Validate item
	 */
	async list<bool, RemoteCallAnswer> validateItem(Dict item, RemoteCallAnswer answer)
	{
		return [true, item, answer];
	}
	
	
	
	/**
	 * Validate primary key
	 */
	async list<bool, RemoteCallAnswer> validatePrimaryKey(Dict pk, RemoteCallAnswer answer)
	{
		return [true, pk, answer];
	}
	
	
	
	/**
	 * Can create item
	 */
	async list<bool, RemoteCallAnswer> canCreateItem(Dict new_item, RemoteCallAnswer answer)
	{
		return [true, new_item, answer];
	}
	
	
	
	/**
	 * Can update item
	 */
	async list<bool, RemoteCallAnswer> canUpdateItem(Dict pk, Dict old_item, Dict new_item, RemoteCallAnswer answer)
	{
		return [true, new_item, answer];
	}
	
	
	
	/**
	 * Can delete item
	 */
	async list<bool, RemoteCallAnswer> canDeleteItem(Dict pk, Dict old_item, RemoteCallAnswer answer)
	{
		return [true, null, answer];
	}
	
	
	
	/**
	 * Build query
	 */
	QueryBuilder buildSearchQuery()
	{
		string table_name = this.getTableName();
		QueryBuilder q = new QueryBuilder()
			.select(table_name)
			.offset(0, 100)
			.order( this.getDefaultSearchOrder() )
		;
		return q;
	}
	
	
	
	/**
	 * Search query
	 */
	async list<QueryBuilder, Collection> searchQuery()
	{
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Build query */
		QueryBuilder q = this.buildSearchQuery();
		
		/* Execute query */
		Cursor cursor = orm.execute(q);
		
		/* Get result */
		Vector items = new Vector();
		while (true)
		{
			Dict row = await cursor.fetch();
			if (row == null)
			{
				break;
			}
			row = await this.fromDatabase(row);
			row = await this.processItem(row);
			items.push(row);
		}
		
		await cursor.close();
		Collection items = await this.processItems( items.toCollection() );
		
		return [q, items];
	}
	
	
	
	/**
	 * Create query
	 */
	async var createQuery(Dict item)
	{
		string table_name = this.getTableName();
		
		/* To database */
		item = await this.convertItem(item);
		item = this.toDatabase(item);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.insert(table_name, item);
		int id = await cursor.lastInsertId();
		await cursor.close();
		
		return id;
	}
	
	
	
	/**
	 * Update query
	 */
	async void updateQuery(Dict pk, Dict item)
	{
		string table_name = this.getTableName();
		
		/* Process item */
		item = await this.convertItem(item);
		item = this.toDatabase(item);
		
		/* Process primary key */
		pk = await this.convertPrimaryKey(pk);
		pk = this.toDatabase(pk);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.update(table_name, pk, item);
		await cursor.close();
	}
	
	
	
	/**
	 * Delete query
	 */
	async void deleteQuery(Dict pk)
	{
		string table_name = this.getTableName();
		
		/* Process primary key */
		pk = await this.convertPrimaryKey(pk);
		pk = this.toDatabase(pk);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.delete(table_name, pk);
		await cursor.close();
	}
	
	
	
	/**
	 * Returns item by pk
	 */
	async Dict getByPrimaryKey(Dict pk)
	{
		string table_name = this.getTableName();
		
		/* Process primary key */
		pk = await this.convertPrimaryKey(pk);
		pk = this.toDatabase(pk);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.select(table_name, pk, 0, 1);
		Dict item = cursor.fetchOne();
		await cursor.close();
		
		return item;
	}
	
	
	
	/**
	 * Search api action
	 */
	static async list searchAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		api.action = "search";
		api.request = request;
		
		/* Init api */
		await api.init();
		
		/* Search query */
		list res = await api.searchQuery();
		QueryBuilder q = res[0];
		Collection items = res[1];
		
		/* Create response */
		Dict response =
		{
			"order": q._order,
			"items": items,
		};
		answer = answer::success(answer, response);
		
		return [request, answer];
	}
	
	
	
	/**
	 * Add api action
	 */
	static async list addAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		api.action = "add";
		api.request = request;
		
		/* Init api */
		await api.init();
		
		/* Get item */
		Dict item = request.data["item"];
		
		/* Validate */
		list res = await api.validateItem(item, answer);
		if (not res[0])
		{
			answer = res[2];
			return [request, answer];
		}
		
		/* Get item */
		item = res[1];
		
		/* Can create */
		list res = await api.canCreateItem(item, answer);
		if (not res[0])
		{
			answer = res[2];
			return [request, answer];
		}
		
		/* Get item */
		item = res[1];
		
		/* Create query */
		var id = await api.createQuery(item);
		
		/* Create response */
		item <= id <= id;
		item = await api.processItem(item);
		Dict response =
		{
			"pk":
			{
				"id": id,
			},
			"item": item,
		};
		answer = answer::success(answer, response);
		
		return [request, answer];
	}
	
	
	
	/**
	 * Update api action
	 */
	static async list updateAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		api.action = "update";
		api.request = request;
		
		/* Init api */
		await api.init();
		
		/* Get item */
		Dict pk = request.data["pk"];
		Dict new_item = request.data["item"];
		
		/* Validate pk */
		list res = await api.validatePrimaryKey(pk, answer);
		if (not res[0])
		{
			answer = res[2];
			return [request, answer];
		}
		
		/* Get item */
		pk = res[1];
		
		/* Validate */
		list res = await api.validateItem(new_item, answer);
		if (not res[0])
		{
			answer = res[2];
			return [request, answer];
		}
		
		/* Get item */
		new_item = res[1];
		
		/* Find item */
		Dict old_item = await api.getByPrimaryKey(pk);
		if (old_item == null)
		{
			throw new ApiException("Item not found", rtl::ERROR_ITEM_NOT_FOUND);
		}
		
		/* Can update */
		list res = await api.canUpdateItem(pk, old_item, new_item, answer);
		if (not res[0])
		{
			answer = res[2];
			return [request, answer];
		}
		
		/* Get item */
		new_item = res[1];
		
		/* Update query */
		await api.updateQuery(pk, new_item);
		
		/* Create response */
		new_item = await api.processItem(new_item);
		Dict response =
		{
			"pk": pk,
			"item": new_item,
		};
		answer = answer::success(answer, response);
		
		return [request, answer];
	}
	
	
	
	/**
	 * Delete api action
	 */
	static async list deleteAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		api.action = "delete";
		api.request = request;
		
		/* Init api */
		await api.init();
		
		/* Get item */
		Dict pk = request.data["pk"];
		
		/* Validate pk */
		list res = api.validatePrimaryKey(pk, answer);
		if (not res[0])
		{
			answer = res[2];
			return [request, answer];
		}
		
		/* Get item */
		pk = res[1];
		
		/* Find item */
		Dict old_item = await api.getByPrimaryKey(pk);
		if (old_item == null)
		{
			throw new ApiException("Item not found", rtl::ERROR_ITEM_NOT_FOUND);
		}
		
		/* Can update */
		list res = await api.canDeleteItem(pk, old_item, answer);
		if (not res[0])
		{
			answer = res[2];
			return [request, answer];
		}
		
		/* Update query */
		await api.deleteQuery(pk);
		
		/* Create response */
		old_item = await api.processItem(old_item);
		Dict response =
		{
			"pk": pk,
			"item": old_item,
		};
		answer = answer::success(answer, response);
		
		return [request, answer];
	}
	
}