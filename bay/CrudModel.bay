/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2018-2019 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Web.CRUD;

use Runtime.Exceptions.RuntimeException;
use Runtime.Interfaces.IntrospectionClass;
use Runtime.CoreStruct;
use Runtime.lib;
use Runtime.MessageRPC;
use Runtime.RuntimeUtils;
use Runtime.ORM.Annotations.Orm;
use Runtime.ORM.DataProviderInterface;
use Runtime.ORM.OrmQuery;
use Runtime.ORM.OrmResult;
use Runtime.Web.CRUD.ItemModel;
use Runtime.Web.CRUD.Annotations.Crud;
use Runtime.Web.CRUD.Annotations.FormValue;
use Runtime.Web.CRUD.Annotations.TableValue;
use Runtime.Web.UI.RenderContainer;


struct CrudModel extends CoreStruct
{
	/* Base */
	string action = "";
	string api_name = "";
	string model_name = "";
	
	/* Search */
	Dict<Collection> fields_info = null;
	Collection<string> fields = null;
	/*Collection<CrudFilterItem> filter = null;*/
	Collection<ItemModel> items = null;
	int page = 0;
	int start = 0;
	int total = 0;
	int limit = 0;
	int max_limit = 0;
	
	/* Current item */
	int index = 0;
	Dict pk = null;
	ItemModel item = null;
	
	/* Error */
	int error_code = 0;
	string error_str = "";
	
	/* Message */
	string orm_connection = "default";
	MessageRPC msg = null;
	
	
	
	/**
	 * Returns api name
	 */
	static string getApiName(string model_name)
	{
		IntrospectionClass info = RuntimeUtils::getClassIntrospection(model_name);
		if (info == null or info.class_info == null) return "";
		
		Crud a = info.class_info.findItem( lib::isInstance(classof Crud) );
		if (a == null) return "";
		
		return a.api;
	}
	
	
	
	/**
	 * Returns table name
	 */
	static string getTableName(string model_name)
	{
		IntrospectionClass info = RuntimeUtils::getClassIntrospection(model_name);
		if (info == null or info.class_info == null) return "";
		
		Orm a = info.class_info.findItem( lib::isInstance(classof Orm) );
		if (a == null) return "";
		
		return a.table_name;
	}
	
	
	
	/**
	 * Load field info
	 */
	static async list<RenderContainer, CrudModel> loadFieldInfo(RenderContainer container, CrudModel crud)
	{
		IntrospectionClass info = RuntimeUtils::getClassIntrospection(crud.model_name);
		
		/* Extends field info */
		Dict<Collection> fields_info = info.fields;
		fields_info = await crud.item::extendsFieldInfo(crud, fields_info);
		
		/* Get all components */
		Vector components = new Vector();
		fields_info.each
		(
			void (Collection<CoreStruct> annotations, string field_name) use (components)
			{
				FormValue form_value = annotations.findItem( lib::isInstance(classof FormValue) );
				if (form_value != null)
				{
					if (form_value.class_name != "") components.push(form_value.class_name);
				}
				TableValue table_value = annotations.findItem( lib::isInstance( classof TableValue ) );
				if (table_value != null)
				{
					if (table_value.class_name != "") components.push(table_value.class_name);
				}
			}
		);
		
		/* Extend layouts */
		crud <= fields_info <= info.fields;
		container <= layout <= modules <= [];
		container <= layout <= components <= components.toCollection();
		
		return [container, crud];
	}
	
	
	
	/**
	 * Extend layout
	 */
	static list<RenderContainer, CrudModel> extendLayout(RenderContainer container, CrudModel crud)
	{
		/* Extend modules */
		fn f = rtl::method (crud.model_name, "modules");
		container <= layout <= modules <= container.layout.modules.concat(f());
		
		/* Extend components */
		fn f = rtl::method (crud.model_name, "components");
		container <= layout <= components <= container.layout.components.concat(f());
		
		return [container, crud];
	}
	
	
	
	/**
	 * Returns table class name
	 */
	lambda html getTableClassName(string field_name, CrudModel crud)
	{
		Collection<CoreStruct> annotations = crud.fields_info.get(field_name, null);
		if (annotations == null) return "";
		
		TableValue table_value = annotations.findItem( lib::isInstance( classof TableValue ) );
		if (table_value == null) return "";
		
		return table_value.class_name;
	}
	
	
	
	/**
	 * Returns forms class name
	 */
	lambda html getFormClassName(string field_name, CrudModel crud)
	{
		Collection<CoreStruct> annotations = crud.fields_info.get(field_name, null);
		if (annotations == null) return "";
		
		FormValue form_value = annotations.findItem( lib::isInstance( classof FormValue ) );
		if (form_value == null) return "";
		
		return form_value.class_name;
	}
	
	
	
	/* -------------------- Search -------------------- */
	
	
	/* Crud search */
	static async list<RenderContainer, CrudModel> actionSearch(RenderContainer container, CrudModel crud)
	{
		list res = [container, crud];
		
		/* Set action */
		crud <= action <= "search";
		
		/* Init Search */
		res = static::actionSearchInit(res[0], res[1]);
		
		/* Search do */
		res = await static::actionSearchDo(res[0], res[1]);
		
		/* Load Annotations */
		res = await static::loadFieldInfo(res[0], res[1]);
		
		/* Extend layout */
		res = static::extendLayout(res[0], res[1]);
		
		return res;
	}
	
	
	
	/**
	 * Search Init
	 */
	static list<RenderContainer, CrudModel> actionSearchInit(RenderContainer container, CrudModel crud)
	{
		Dict params = container.route_params;
		Dict query = container.request.query;
		fn f = rtl::method (crud.model_name, "getTableFields");
		Collection<string> fields = f();
		/*Collection<CrudFilterItem> filter = (Collection<CrudFilterItem>) params.get("filter", null);*/
		
		int page = (int) query.get("page", 0);
		int limit = (int) query.get("limit", 30);
		if (limit <= 0) limit = 1;
		if (limit > crud.max_limit) limit = crud.max_limit;
		
		crud = crud.copy
		{
			"api_name": static::getApiName(crud.model_name),
			"fields": fields,
			"page": page,
			"limit": limit,
			"start": page * limit,
			"item": rtl::newInstance(crud.model_name),
		};
		
		return [container, crud];
	}
	
	
	
	/**
	 * Search Do
	 */
	static async list<RenderContainer, CrudModel> actionSearchDo(RenderContainer container, CrudModel crud)
	{
		MessageRPC<Dict> api_res = await @->sendMessage
		(
			new MessageRPC
			{
				"api_name": crud.api_name,
				"space_name": "Runtime.Web.CRUD.CrudInterface",
				"method_name": "search",
				"data":
				{
					"fields": crud.fields,
					/*"filter": crud.filter,*/
					"order": crud.order,
					"page": crud.page,
					"limit": crud.limit,
				}
				"session": container.session,
			}
		);
		
		if (api_res->isSuccess())
		{
			OrmResult res = api_res.response;
			crud <= items <= res.items;
			crud <= total <= res.total;
		}
		else
		{
			crud <= error_code <= api_res.code;
			crud <= error_str <= api_res.error;
		}
		
		return [container, crud];
	}
	
	
	
	#ifdef BACKEND then
	
	/**
	 * Search Api
	 */
	static async MessageRPC apiSearch(MessageRPC msg, CrudModel crud)
	{
		/* Set action */
		crud <= action <= "apiSearch";
		
		DataProviderInterface provider = @->getProvider(classof DataProviderInterface, crud.orm_connection);
		
		string model_name = crud.model_name;
		string table_name = static::getTableName(model_name);
		string fields = "";
		string where = "";
		string params = "";
		int page = 1;
		int limit = 30;
		
		OrmQuery q = new OrmQuery()
			-> select ( table_name, fields )
			-> asModel ( model_name, true )
			-> where ( where, params )
			-> offset ( page, limit )
		;
		
		OrmResult res = await q->execute(provider);
		return msg->success(res);
	}
	
	#endif
	
	
	
	/* ------------------ Add or Edit ----------------- */
	
	
	/* Crud add */
	static async list<RenderContainer, CrudModel> actionAdd(RenderContainer container, CrudModel crud)
	{
		list res = [container, crud];
		
		/* Set action */
		crud <= action <= "add";
		
		/* Init Search */
		res = static::actionSaveInit(res[0], res[1]);
		
		/* Search do */
		res = await static::actionSaveDo(res[0], res[1]);
		
		/* Load Annotations */
		res = await static::loadFieldInfo(res[0], res[1]);
		
		/* Extend layout */
		res = static::extendLayout(res[0], res[1]);
		
		return res;
	}
	
	
	
	/* Crud edit */
	static async list<RenderContainer, CrudModel> actionEdit(RenderContainer container, CrudModel crud)
	{
		list res = [container, crud];
		
		/* Set action */
		crud <= action <= "edit";
		
		/* Init Search */
		res = static::actionSaveInit(res[0], res[1]);
		
		/* Search do */
		res = await static::actionSaveDo(res[0], res[1]);
		
		/* Load Annotations */
		res = await static::loadFieldInfo(res[0], res[1]);
		
		/* Extend layout */
		res = static::extendLayout(res[0], res[1]);
		
		return res;
	}
	
	
	
	/**
	 * Save Init
	 */
	static list<RenderContainer, CrudModel> actionSaveInit(RenderContainer container, CrudModel crud)
	{
		int id = (int) container.route_params.get("id", 0);
		crud = crud.copy
		{
			"api_name": static::getApiName(crud.model_name),
			"item": rtl::newInstance(crud.model_name),
			"pk":
			{
				"id": id,
			},
		};
		return [container, crud];
	}
	
	
	
	/**
	 * Save Do
	 */
	static async list<RenderContainer, CrudModel> actionSaveDo(RenderContainer container, CrudModel crud)
	{
		MessageRPC<Dict> api_res = await @->sendMessage
		(
			new MessageRPC
			{
				"api_name": crud.api_name,
				"space_name": "Runtime.Web.CRUD.CrudInterface",
				"method_name": "getByID",
				"data":
				{
					"pk": crud.pk,
				}
				"session": container.session,
			}
		);
		
		if (api_res->isSuccess())
		{
			ItemModel res = api_res.response;
			crud <= item <= res;
		}
		else
		{
			crud <= error_code <= api_res.code;
			crud <= error_str <= api_res.error;
		}
		
		return [container, crud];
	}
	
	
	
	#ifdef BACKEND then
	
	
	/**
	 * Search Api
	 */
	static async MessageRPC apiGetByID(MessageRPC msg, CrudModel crud)
	{
		/* Set action */
		crud <= action <= "apiGetByID";
		
		/* Get connection */
		DataProviderInterface provider = @->getProvider(classof DataProviderInterface, crud.orm_connection);
		string model_name = crud.model_name;
		string table_name = static::getTableName(model_name);
		
		/* Get filter */
		string fields = "";
		string where = "id=:id";
		Dict params = 
		{
			"id": (int) rtl::attr(msg.data, ["pk", "id"], 0),
		};
		int page = 1;
		int limit = 30;
		
		OrmQuery q = new OrmQuery()
			-> select ( table_name, fields )
			-> asModel ( model_name, true )
			-> where ( where, params )
		;
		ItemModel res = await q->fetchOne(provider);
		return msg->success(res);
	}
	
	
	
	/**
	 * Save
	 */
	static async MessageRPC apiSave(MessageRPC msg, CrudModel crud)
	{
		/* Set action */
		crud <= action <= "apiSave";
		
		/* Get connection */
		DataProviderInterface provider = @->getProvider(classof DataProviderInterface, crud.orm_connection);
		string model_name = crud.model_name;
		string table_name = static::getTableName(model_name);
		
		/* Get filter */
		int id = (int) rtl::attr(msg.data, ["pk", "id"], 0);
		Dict item = (Dict) rtl::attr(msg.data, ["pk", "item"], null);
		item = item.unset("id");
		
		OrmQuery q = new OrmQuery()
			-> update ( table_name, fields )
			-> set( item )
			-> where ( "id=:id", {"id": id} )
		;
		
		OrmResult res = await q->execute(provider);
		return msg->success(res);
	}
	
	
	#endif
	
	
	/* -------------------- Delete -------------------- */
	
	
	/* Crud delete */
	static async list<RenderContainer, CrudModel> actionDelete(RenderContainer container, CrudModel crud)
	{
		crud <= action <= "actionDelete";
		crud = static::actionDeleteInit(container, crud);
		crud = await static::actionDeleteDo(container, crud);
		return [container, crud];
	}
	
	
}
